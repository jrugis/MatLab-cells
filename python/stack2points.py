# -*- coding: utf-8 -*-################################################################################# 08.11.19# J.rugis################################################################################import matplotlib.pyplot as pltfrom matplotlib.backend_bases import MouseButtonfrom skimage import ioimport stack_utils as su    ################################################################################ GLOBAL CONSTANTS###############################################################################IMAGE_STACK = 'stackB.tif'POINTS_OUT_FILE = 'points.txt'################################################################################ CLASSES AND FUNCTIONS###############################################################################class cTracker(object):    def __init__(self, ax, A):        ax.set_title('use scroll wheel to navigate images')        self.ax = ax               # plot axis        self.A = A                 # image stack data        self.slices, rows, cols = A.shape        self.lP = [[] for n in range(self.slices)]  # list of circle center points        self.lA = [[] for n in range(self.slices)]  # list of artist circles to draw        self.ind = 0               # displayed stack frame        for t in su.get_points(POINTS_OUT_FILE, self.slices):            self.add_point_artist(t[0], t[1], t[2]) # t is tuple (slice, x, y)        self.im = ax.imshow(A[self.ind, :, :],cmap='gray')        self.update()    def add_point_artist(self, ind, x, y):        self.lP[ind].append((x,y)); su.save_points(POINTS_OUT_FILE, self.lP)        self.lA[ind].append(self.ax.add_artist(                plt.Circle((x, y), 22, color=(1,1,0), lw=1, fill=False, picker=1)))        if ind != self.ind: # if not on the visible stack frame, remove the artist            self.lA[ind][-1].remove()                def onscroll(self, event):          #print("%s %s" % (event.button, event.step))        # stack scrolling        [a.remove() for a in self.lA[self.ind]]        if event.button == 'down':            if self.ind < self.slices - 1 : self.ind = (self.ind + 1)        else:             if self.ind > 0 : self.ind = (self.ind - 1)        [self.ax.add_artist(a) for a in self.lA[self.ind]]        self.update()    def onpress(self, event):        # adding circles        if event.button is MouseButton.LEFT and event.inaxes:            x = int(event.xdata)            y = int(event.ydata)            self.add_point_artist(self.ind, x, y)            self.im.axes.figure.canvas.draw()    def onpick(self, event):        # deleting circles        if event.mouseevent.button is MouseButton.RIGHT:            i = self.lA[self.ind].index(event.artist)            self.lP[self.ind].pop(i); su.save_points(POINTS_OUT_FILE, self.lP)            self.lA[self.ind].pop(i).remove()            self.im.axes.figure.canvas.draw()    def update(self):        self.im.set_data(self.A[self.ind, :,:])        self.ax.set_ylabel('slice %s' % (self.ind + 1))        self.im.axes.figure.canvas.draw()################################################################################ MAIN PROGRAM################################################################################### get an image stackA = io.imread(IMAGE_STACK)#### display the image stackfig, ax = plt.subplots(1, 1)tracker = cTracker(ax, A)fig.canvas.mpl_connect('scroll_event', tracker.onscroll)      # for stack scrollingfig.canvas.mpl_connect('button_press_event', tracker.onpress) # for adding circlesfig.canvas.mpl_connect('pick_event', tracker.onpick)          # for deleting circlesplt.show() # enter interactive GUI event loop###############################################################################